"""Tools for dividing datasets into train and test sets.

This submodule provides classes for generating random train-test splits and
K-Folds for numpy arrays or datasets. The classes in this module inherits from
the abstract base class DataSplitter, which provides a consistent API for
different data splitting algorithms.

Classes
-------
DataSplitter
    Abstract base class for data splitters in this module.
RandomSplit(DataSplitter)
    Random train-test splits for numpy arrays or datasets.
KFold(DataSplitter)
    Generate K-Folds for numpy arrays or datasets.
"""

import numpy as np
from numpy.typing import NDArray
from abc import ABC, abstractmethod

class DataSplitter(ABC):
    """Abstract base class for data splitters.
    
    Provides a consistent API for different data splitting algorithms.

    Attributes
    ----------
    n_splits: int
        Number of splits to generate.

    Methods
    -------
    split_idxs
        Generate train-test splits of indices for a dataset.
    split_Xy_data
        Generate random train-test splits for a dataset.
    """
    @abstractmethod
    def __init__(self, n_splits: int = 1) -> None:
        """Initialize DataSplitter object.

        Parameters
        ----------
        n_splits: int, default=1
            Number of splits to generate.
        """
        self.n_splits = n_splits

    @abstractmethod
    def split_idxs(
        self, 
        sample_size: int
    ) -> list[tuple[NDArray, NDArray]]:
        """Generate train-test splits of indices for a dataset.
        
        Parameters
        ----------
        sample_size: int
            Number of samples in the dataset to generate indices for.

        Returns
        -------
        train_test: list of tuples or tuple
            Returns a list of self.train_size tuples. Each tuple contains two 
            numpy arrays: one for training indices, and one for test indices.

        Notes
        -----
        - This method always generates a list of splits, even if n_splits=1.
        """
        pass
    
    @abstractmethod
    def split_Xy_data(
        self,
        X: NDArray, 
        y: NDArray
    ) -> list[tuple[NDArray, NDArray]]:
        """Generate random train-test splits for a dataset.

        Parameters
        ----------
        X: NDArray
            NumPy feature matrix, shape (n_samples, n_features)
        y: NDArray
            NumPy target vector, shape (n_samples,)

        Raises
        ------
        ValueError
            If X and y do not have the same number of samples.

        Returns
        -------
        train_test: list of tuples or tuple
            Returns a list of n_splits tuples. Each tuple contains four numpy
            arrays, (X_train, X_test, y_train, y_test).
        """
        pass


class RandomSplit(DataSplitter):
    """Random train-test splits for numpy arrays or datasets.

    Notes
    -----
    - This class generates random train-test splits for numpy arrays.
    - The splits are generated by randomly shuffling the sample indices,
      using numpy's default random number generator (PCG64).
    """

    def __init__(
            self,
            train_size: float = 0.8,
            n_splits: int = 1,
            random_state=None
    ) -> None:
        """Initialize RandomSplit object.

        Parameters
        ----------
        train_size: float, default=0.8
            Proportion of samples to include in the training set.
        n_splits: int, default=1
            Number of splits to generate.
        random_state: int, optional
            Seed for the random number
        """
        self.train_size = train_size
        self.n_splits = n_splits
        self._rng = np.random.default_rng(random_state)

    def split_idxs(
            self,
            sample_size: int
    ) -> list[tuple[NDArray, NDArray]]:
        """Generate random train-test splits of indices for a dataset.

        Parameters
        ----------
        sample_size: int
            Number of samples in the dataset to generate indices for.

        Returns
        -------
        train_test: list of tuples or tuple
            Returns a list of self.n_splits tuples. Each tuple contains two 
            numpy arrays: one for training indices, and one for test indices.

        Notes
        -----
        - This method always generates a list of splits, even if n_splits=1. 
        - The training set size is determined by self.train_size.
        """
        idxs = np.arange(sample_size)
        self._rng.shuffle(idxs)
        train_test = []
        for _ in range(self.n_splits):
            train_test.append((idxs[:int(sample_size * self.train_size)],
                               idxs[int(sample_size * self.train_size):]))
        return train_test

    def split_Xy_data(
            self,
            X: NDArray,
            y: NDArray
    ) -> list[tuple[NDArray]]:
        """Generate random train-test splits for a dataset.

        Parameters
        ----------
        X: NDArray
            NumPy feature matrix, shape (n_samples, n_features)
        y: NDArray
            NumPy target vector, shape (n_samples,)

        Raises
        ------
        ValueError
            If X and y do not have the same number of samples.

        Returns
        -------
        train_test: list of tuples or tuple
            Returns a list of n_splits tuples. Each tuple contains four numpy
            arrays, (X_train, X_test, y_train, y_test).
        """
        if X.shape[0] != y.shape[0]:
            raise ValueError("X and y must have the same number of samples.")
        idxs = self.split_idxs(X.shape[0])
        train_test = [(X[train], X[test], y[train], y[test])
                      for train, test in idxs]
        return train_test


class KFold(DataSplitter):
    """Generate K-Folds for numpy arrays or datasets.

    Notes
    -----
    - This class generates K-Folds for numpy arrays.
    - The splits are generated by shuffling the sample indices and dividing
      them into n_splits groups.
    - Randomization is done using numpy's default random number generator (PCG64).
    """

    def __init__(
            self,
            n_splits: int = 5,
            random_state=None
    ) -> None:
        """Initialize KFold object.

        Parameters
        ----------
        n_splits: int, default=5
            Number of folds to generate.
        random_state: int, optional
            Seed for the random number
        """
        self.n_splits = n_splits
        self._rng = np.random.default_rng(random_state)

    def split_idxs(
            self,
            sample_size: int
    ) -> list[tuple[NDArray, NDArray]]:
        """Generate K-Folds for a dataset of given size.

        Parameters
        ----------
        sample_size: int
            Number of samples in the dataset.

        Returns
        -------
        folds: list of tuples
            List of tuples, each containing two numpy arrays: one for training
            indices, and one for test indices.
        """
        idxs = np.arange(sample_size)
        self._rng.shuffle(idxs)
        folds = []
        fold_size = sample_size // self.n_splits
        for i in range(self.n_splits):
            start = i * fold_size
            end = start + fold_size
            test_idxs = idxs[start:end]
            train_idxs = np.concatenate((idxs[:start], idxs[end:]))
            folds.append((train_idxs, test_idxs))
        return folds

    def split_Xy_data(
            self,
            X: NDArray,
            y: NDArray
    ) -> list[tuple[NDArray, NDArray]]:
        """Generate K-Folds for a dataset.

        Parameters
        ----------
        X: NDArray
            NumPy feature matrix, shape (n_samples, n_features)
        y: NDArray
            NumPy target vector, shape (n_samples,)

        Raises
        ------
        ValueError
            If X and y do not have the same number of samples.

        Returns
        -------
        folds: list of tuples
            List of tuples, each containing four numpy arrays:
              (X_train, X_test, y_train, y_test)
        """
        if X.shape[0] != y.shape[0]:
            raise ValueError("X and y must have the same number of samples.")
        idxs = self.split_idxs(X.shape[0])
        folds = [(X[train], X[test], y[train], y[test])
                 for train, test in idxs]
        return folds
